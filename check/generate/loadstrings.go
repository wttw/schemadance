//+build generate

package main

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig"
	"github.com/fatih/structtag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

func main() {
	if len(os.Args) < 3 {
		log.Fatalln("generate <driver> <type>...")
	}
	var dbType, dbQuery, dbImport string
	switch os.Args[1] {
	case "pq":
		dbType = "*sql.Conn"
		dbQuery = "QueryContext"
		dbImport = "database/sql"
	case "pgx":
		dbType = "*pgx.Conn"
		dbQuery = "Query"
		dbImport = "github.com/jackc/pgx/v4"
	default:
		log.Fatalf("only support pq and pgx, not %s", os.Args[1])
	}
 	targets := map[string]struct{}{}
	for _, v := range os.Args[2:] {
		targets[v] = struct{}{}
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, 0)
	if err != nil {
		log.Fatalf("failed to ParseDir: %v", err)
	}
	for packageName, pkg := range pkgs {
		ast.Inspect(pkg, func(n ast.Node) bool {
			t, ok := n.(*ast.TypeSpec)
			if !ok {
				return true
			}

			if t.Type == nil {
				return true
			}

			structName := t.Name.Name
			_, ok = targets[structName]
			if !ok {
				return true
			}
			s, ok := t.Type.(*ast.StructType)
			if !ok {
				return true
			}

			var fieldNames []string
			for _, field := range s.Fields.List {
				if field.Tag != nil && field.Tag.Kind == token.STRING {
					tagstr, err := strconv.Unquote(field.Tag.Value)
					if err != nil {
						log.Fatal("bad quoting in struct tag '%s': %v", field.Tag.Value, err)
					}
					tags, err := structtag.Parse(tagstr)
					if err != nil {
						log.Fatal("bad struct tag '%s': %v", field.Tag.Value, err)
					}
					tag, err := tags.Get("load")
					if err == nil {
						// tag exists
						if tag.HasOption("-") {
							continue
						}
					}
				}
				fieldNames = append(fieldNames, field.Names[0].Name)
			}
			generate(packageName, structName, fieldNames, dbType, dbQuery, dbImport)
			return false
		})
	}
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake  = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

const loadTpl = `
// Code generated by generate.go DO NOT EDIT.

package {{ .Package }}

import (
    "context"
    "{{ .Import }}"
)

func Load{{ .Struct }}(db {{ .DbType }}, sqlClause string) ([]{{ .Struct }}, error) {
    sql := ` + "`" + `select {{ range $i, $v := .Fields}}{{ if $i}}, {{end}}format("%L", {{ snake . }}{{ end}} from ` + "`" + ` + sqlClause
    rows, err := db.{{ .DbQuery }}(context.Background(), sql)
    if err != nil {
        return nil, err
    }
    var ret []{{.Struct}}
    for rows.Next() {
        var c {{.Struct}}
        err = rows.Scan(
{{ range .Fields}}&c.{{.}},
{{ end }}        )
        if err != nil {
            return nil, err
        }
        ret = append(ret, c)
    }
    if rows.Err() != nil {
        return nil, rows.Err()
    }
    return ret, nil
}
`

func generate(packageName string, structName string, fieldNames []string, dbType, dbQuery, dbImport string) {
	tpl := template.Must(template.New("base").Funcs(sprig.HermeticTxtFuncMap()).Funcs(template.FuncMap{
		"snake": toSnakeCase,
	}).Parse(loadTpl))

	var generated bytes.Buffer
	err := tpl.Execute(&generated, struct{
		Struct string
		Fields []string
		DbType string
		DbQuery string
		Package string
		Import string
	}{
		Struct: structName,
		Fields: fieldNames,
		DbType: dbType,
		DbQuery: dbQuery,
		Package: packageName,
		Import: dbImport,
	})
	if err != nil {
		log.Fatalln(err)
	}
	formatted, err := format.Source(generated.Bytes())
	if err != nil {
		fmt.Println(generated.String())
		log.Fatalln(err)
	}
	outputFile := strings.TrimSuffix(packageName, ".go") + "_" + strings.ToLower(structName) + ".gen.go"
	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		log.Fatalln(err)
	}
}